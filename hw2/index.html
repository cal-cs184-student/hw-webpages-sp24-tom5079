<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c7{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c6{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c5{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c10{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c4{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9 doc-content"><p class="c10 title" id="h.74jycx5l9w90"><span class="c8">HW 2 Write Up</span></p><p class="c6 subtitle" id="h.g5uba4gwjo5u"><span class="c7">Jesse Lutan, Minseok Son</span></p><h1 class="c2" id="h.unkrr843acze"><span class="c3">Overview</span></h1><p class="c0"><span class="c1">In homework 2 part 1, we estimated bezier curves in 1D with the de Casteljau subdivision and separable de Casteljau algorithms. In part 2, we transitioned to 3D geometric models and implemented Phong shading using area-weighted vertex normals, edge flipping and splitting, and the loop subdivision algorithm which applies these transformations to &ldquo;smoothen&rdquo; a model with a given number of vertices by up-sampling&ndash;nearly doubling the total vertex count.</span></p><h1 class="c2" id="h.756s8uv2ffe"><span class="c3">Part 1: Bezier Curves with 1D de Casteljau Subdivision</span></h1><p class="c0"><span class="c1">De Casteljau algorithm provides a way to generate curves using a set of control points. In order to evaluate Bezier curves, we recursively applied linear interpolation with fixed ratio t until we have one point.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 410.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 410.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 409.33px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 409.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c2" id="h.jat44mhoy5jf"><span class="c3">Part 2: Bezier Surfaces with Separable 1D de Casteljau</span></h1><p class="c0"><span class="c1">Instead of one time variable t, we can introduce 2D control variable u and v. We can evaluate bezier curves along one axis using u, and we can apply de casteljau algorithm again on the set of points on the bezier curve to obtain bezier surface.</span></p><p class="c0"><span class="c1">In my implementation, evaluateStep applies de casteljau algorithm to obtain next step in bezier curve, evaluate1D evaluates the point on the bezier curve by calling evaluateStep until we have one point, evaluate evaluates a point on bezier surface by evaluating with u on one axis and v on the other axis.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 412.00px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 412.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c2" id="h.8gzranyxagva"><span class="c3">Part 3: Area-Weighted Vertex Normals</span></h1><p class="c0"><span class="c1">The area-weighted normal at a given vertex is computed by iterating over its incident faces, computing the area of the corresponding triangles, multiplying this area by the face&rsquo;s unit normal and summing these values into a 3D vector. The area of a face is found by taking its vertices, found by iterating over the face&rsquo;s inner half edges, forming 2 vectors originating from one of these vertices, and dividing the magnitude of the cross product of the vectors by 2. The unit normal is the normalized cross product.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 214.38px;"><img alt="" src="images/image8.png" style="width: 307.50px; height: 214.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.50px; height: 214.61px;"><img alt="" src="images/image16.png" style="width: 298.50px; height: 214.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c4"><span class="c1"></span></p><h1 class="c2" id="h.hw5ucqf8tbmi"><span class="c3">Part 4: Edge flip</span></h1><p class="c0"><span class="c1">I implemented an edge flip by first storing all the necessary iterators on an array, and then reassigning them one by one. I ended up with a really clean code and I actually did not have to debug any of the code.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 406.67px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 406.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 405.33px;"><img alt="" src="images/image18.png" style="width: 624.00px; height: 405.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c2" id="h.52qykc8kqo59"><span class="c3">Part 5: Edge Split</span></h1><p class="c0"><span class="c1">Edge splitting involved creating 1 new vertex, 3 new edges, 2 new faces, and 6 new half edges. To integrate these elements into the model, the relevant pointers of each required updating. For the vertex, edges, and faces, each was assigned a half edge arbitrarily or according to the spec. The new half edges associated with the newly added edges needed to be fully initialized with pointers to the next half edge, twin, vertex, edge and face. Some existing half edges also needed to be updated with pointers to a new next half edge, new faces, and the new vertex. The position of the new vertex is computed as the midpoint of the edge being split.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c1">Splitting</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 269.83px; height: 267.20px;"><img alt="" src="images/image3.png" style="width: 269.83px; height: 267.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 256.61px; height: 267.20px;"><img alt="" src="images/image13.png" style="width: 256.61px; height: 267.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Splitting + flipping</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 269.50px; height: 265.11px;"><img alt="" src="images/image19.png" style="width: 269.50px; height: 265.11px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 255.87px; height: 264.83px;"><img alt="" src="images/image10.png" style="width: 255.87px; height: 264.83px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c2" id="h.3hxasqqgbx2c"><span class="c3">Part 6: Loop Subdivision</span></h1><p class="c0"><span class="c1">Our loop subdivision closely adhered to the guidelines given in the function specification. First, the new positions of old and new vertices are computed according to the weighted sum formula presented in lecture, using only vertex positions from the original mesh, and original vertices and edges are marked &ldquo;old&rdquo;. Every edge in the original mesh is then split in arbitrary order, and newly added vertices and edges are marked &ldquo;new&rdquo;. We prevent splitting new edges by only splitting edges connecting 2 &ldquo;old&rdquo; vertices. New edges connecting old and new vertices are flipped and new positions are updated for every vertex in the resulting mesh.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c1">After loop subdivision, models generally look smoother and rounder since the vertex count is almost doubled (excluding boundaries) and edges flipped in such a way to make the faces of the subdivided mesh as symmetrical as algorithmically possible. After 5 iterations, sharp corners and edges almost disappear into smooth curves.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 268.50px; height: 247.77px;"><img alt="" src="images/image7.png" style="width: 268.50px; height: 247.77px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 265.95px; height: 248.50px;"><img alt="" src="images/image6.png" style="width: 265.95px; height: 248.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c1">Splitting the edges incident to a vertex multiple times seems to reduce the &ldquo;smoothing&rdquo; of edges and corners and keep more of the original geometry. More splits results in greater preservation.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 267.50px; height: 267.50px;"><img alt="" src="images/image12.png" style="width: 267.50px; height: 267.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 268.50px; height: 268.50px;"><img alt="" src="images/image9.png" style="width: 268.50px; height: 268.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">By pre-splitting and flipping the edges of a cube in a particular order, loop subdivision can produce more complex shapes like this hole.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 275.24px; height: 250.50px;"><img alt="" src="images/image5.png" style="width: 275.24px; height: 250.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 275.50px; height: 250.71px;"><img alt="" src="images/image17.png" style="width: 275.50px; height: 250.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c1">The asymmetry of the cube after some iterations of loop subdivision is a result of the initial asymmetry of the edges of the original mesh. The algorithm will preserve this asymmetry as vertices with greater degrees begin to &ldquo;pull&rdquo; towards the center of the shape while vertices with lesser degrees remain extruding due to the weighted sum involved in computing new vertex positions. Splitting face edges so that every diagonal edge becomes an &ldquo;X&rdquo; gives the mesh a symmetrical pattern that will result in a symmetrical geometry after applying loop subdivision.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c5">Before pre-processing</span></p><p class="c0"><span class="c1">0 iterations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 iterations</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 294.84px; height: 283.50px;"><img alt="" src="images/image2.png" style="width: 294.84px; height: 283.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.50px; height: 284.59px;"><img alt="" src="images/image21.png" style="width: 290.50px; height: 284.59px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0 c4"><span class="c5"></span></p><p class="c0 c4"><span class="c5"></span></p><p class="c0 c4"><span class="c5"></span></p><p class="c0"><span class="c5">After pre-processing</span></p><p class="c0"><span>0 iterations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 iterations</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 302.76px; height: 290.10px;"><img alt="" src="images/image4.png" style="width: 302.76px; height: 290.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.50px; height: 290.38px;"><img alt="" src="images/image20.png" style="width: 305.50px; height: 290.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>